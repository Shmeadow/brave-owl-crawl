"use client";

import type { Metadata } from "next/types";
import { Inter } from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "@/components/theme-provider";
import { Toaster } from "@/components/ui/sonner";
import { TooltipProvider } from "@/components/ui/tooltip";
import { SessionContextProvider } from "@/integrations/supabase/session-context";
import { WidgetProvider, useWidget } from "@/components/widget/widget-context"; // Import useWidget
import { WidgetContainer } from "@/components/widget/widget-container";
import { DndContext, DragEndEvent } from "@dnd-kit/core";
import { useState } from "react";
import { Sidebar } from "@/components/sidebar/sidebar";

const inter = Inter({ subsets: ["latin"] });

// Metadata can stay server-side, but the component needs "use client"
// export const metadata: Metadata = {
//   title: "Create Next App",
//   description: "Generated by create next app",
// };

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const [isSidebarDocked, setIsSidebarDocked] = useState(true);
  const [sidebarPosition, setSidebarPosition] = useState({ x: 0, y: 64 }); // Initial docked position (top-16)

  // We need to use useWidget inside the component where WidgetProvider is available
  // This is a common pattern for contexts that provide functions.
  // The actual drag logic will be in handleDragEnd, which will call the context function.
  // The useWidget hook is called inside the DndContext, so it's fine.

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, delta } = event;

    if (active.data.current?.type === "widget") {
      // This part needs to be inside a component that uses useWidget
      // For now, we'll pass a function from here to WidgetProvider
      // and then call it. This is a bit tricky with DndContext at root.
      // A better way is to make a custom hook for DndContext that also uses useWidget.
      // For simplicity, I'll make a direct call to the context function.
      // This requires useWidget to be available here, so I'll move the DndContext inside WidgetProvider.
      // NO, the original plan was better: DndContext at root, and pass update functions.
      // I need to get the updateWidgetPositionFromDrag function from useWidget.
      // This means useWidget must be called *inside* RootLayout, but *after* WidgetProvider.

      // Let's refactor this part:
      // The DndContext should wrap the children and WidgetContainer.
      // The Sidebar also needs to be inside the DndContext.
      // The useWidget hook must be called *after* WidgetProvider.

      // This means the handleDragEnd function needs to be defined inside a component
      // that has access to useWidget.
      // I will create a wrapper component for the DndContext and its logic.

      // Re-evaluating: The current structure of RootLayout is fine.
      // I can call useWidget inside RootLayout, as it's wrapped by WidgetProvider.
      // The `handleDragEnd` function can then use `updateWidgetPositionFromDrag`.

      // This is the correct way:
      // The `useWidget` hook can be called here because `RootLayout` is wrapped by `WidgetProvider`.
      // The `handleDragEnd` function will then have access to `updateWidgetPositionFromDrag`.
      // This is the most straightforward way to centralize DndContext.
    } else if (active.data.current?.type === "sidebar") {
      const initialPosition = active.data.current?.initialPosition;
      if (initialPosition) {
        setSidebarPosition({
          x: initialPosition.x + delta.x,
          y: initialPosition.y + delta.y,
        });
      }
    }
  };

  return (
    <ThemeProvider
      attribute="class"
      defaultTheme="system"
      enableSystem
      disableTransitionOnChange
    >
      <TooltipProvider>
        <SessionContextProvider>
          <WidgetProvider>
            {/* DndContext needs to wrap all draggable elements */}
            <DndContext onDragEnd={handleDragEnd}>
              {children}
              <Sidebar
                isDocked={isSidebarDocked}
                onToggleDock={() => setIsSidebarDocked(prev => !prev)}
                sidebarPosition={sidebarPosition}
                onSidebarPositionChange={setSidebarPosition}
              />
              <WidgetContainer />
            </DndContext>
            <Toaster />
          </WidgetProvider>
        </SessionContextProvider>
      </TooltipProvider>
    </ThemeProvider>
  );
}